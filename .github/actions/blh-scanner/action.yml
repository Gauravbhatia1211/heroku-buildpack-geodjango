# This file defines the "module" itself.
# It tells GitHub what inputs it takes and how to run it.
name: 'MISS Framework - BLH Scanner'
description: 'Scans a repository for hijackable broken links based on the MISS framework.'
author: 'Gaurav Bhatia & Raj Sharma'

inputs:
  scan-directory:
    description: 'The directory to scan. Defaults to the root.'
    required: false
    default: '.'
  report-name:
    description: 'The name of the JSON report file.'
    required: false
    default: 'blh_report.json'
  # --- NEW ---
  # Add the level input to filter the noise
  level:
    description: "The minimum vulnerability level to report: 'warning' (all broken) or 'critical' (only hijackable)."
    required: false
    default: 'critical' 
  # --- END NEW ---

outputs:
  report-path:
    description: 'The path to the generated JSON report.'
    value: ${{ steps.run_scan.outputs.report_path }}

runs:
  using: 'composite' # This lets us run a series of simple shell commands
  steps:
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install dependencies
      shell: bash
      run: pip install -r ${{ github.action_path }}/requirements.txt

    - name: Run BLH Scanner
      id: run_scan
      shell: bash
      run: |
        python ${{ github.action_path }}/scan.py \
          --directory ${{ inputs.scan_directory }} \
          --output ${{ inputs.report-name }} \
          --level ${{ inputs.level }} # Pass the new level to the script
        
        echo "report_path=${{ inputs.report-name }}" >> $GITHUB_OUTPUT
```eof

### 2. The Upgraded `scan.py` (Smarter and cleaner)

```python:The Upgraded Scanner Engine (v2.3):blh-scanner/scan.py
"""
MISS Framework - BLH Scanner (scan.py)
VERSION 2.3
- Added --level flag ('warning' or 'critical') to filter noise.
- Added IGNORE_DOMAINS to skip placeholders (example.com)
  and unreliably-checked domains (github.com).
- Added domain validation to skip garbage (like 'http', '...', '``')

This is the core "Scan" pillar prototype. It finds links and checks
if they are not just broken, but *hijackable*.
"""

import os
import re
import requests
import whois
import dns.resolver
import json
import argparse
from urllib.parse import urlparse
import time

# REGEX to find URLs.
URL_REGEX = r'https?://[^\s"\'()<>\[\]]+'

# Directories to ignore
IGNORE_DIRS = ('.git', '.github', 'node_modules', 'dist', 'build', '.venv')

# --- NEW: Domains to ignore ---
# These are either placeholders (example.com) or domains that
# fail DNS checks incorrectly (github.com) and are not hijackable anyway.
IGNORE_DOMAINS = (
    'example.com', 'localhost', '127.0.0.1',
    'github.com', 'bitbucket.org', 'gitlab.com',
    'twitter.com', 'facebook.com', 'linkedin.com',
    'google.com', 'pypi.org', 'python.org', 'pythonhosted.org',
    'bugs.python.org', 'docs.python.org', 'pypi.python.org',
    'bugs.jython.org', 'hg.python.org'
)

# Custom User-Agent
REQUEST_HEADERS = {
    'User-Agent': 'MISS-Framework-Scanner/2.3'
}

def is_valid_domain(domain):
    """Simple check to filter out garbage like 'http', '...', '``'"""
    if not domain:
        return False
    # Filter domains that are just punctuation or garbage
    if not re.search(r'[a-zA-Z]', domain):
        return False
    if domain in ('http', 'https', '...'):
        return False
    if not re.match(r'^[a-zA-Z0-9.-]{3,}$', domain):
        # Must be at least 3 chars and only valid domain chars
        return False
    if domain.startswith('.') or domain.endswith('.'):
        return False
    if '...' in domain:
        return False
    return True

def find_links_in_file(filepath):
    """Finds all unique URLs in a single file."""
    links = set()
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
            for match in re.finditer(URL_REGEX, content):
                links.add(match.group(0))
    except Exception:
        pass # Ignore binary files or read errors
    return links

def check_http_status(url):
    """
    Performs a HEAD request for a quick status check.
    This is for generic domains, not the special S3/Azure checks.
    """
    try:
        response = requests.head(url, timeout=5, allow_redirects=True, headers=REQUEST_HEADERS)
        if 400 <= response.status_code <= 499:
            return "Broken (Client Error)"
        elif 500 <= response.status_code <= 599:
            return "Broken (Server Error)"
        else:
            return "OK"
    except requests.exceptions.Timeout:
        return "Broken (Timeout)"
    except requests.exceptions.ConnectionError:
        return "Broken (Connection Error)"
    except Exception:
        return "Broken (Unknown Error)"

def check_s3_bucket(url):
    """
    Specific check for S3 'NoSuchBucket' vulnerability.
    This is the Reddit rpan-studio case.
    """
    try:
        response = requests.get(url, timeout=5, headers=REQUEST_HEADERS)
        if response.status_code == 404 and "<Code>NoSuchBucket</Code>" in response.text:
            return "Broken", "CRITICAL: S3 bucket does not exist and is available for registration ('NoSuchBucket')."
        if response.status_code == 200:
             return "OK", None
        return f"Info ({response.status_code})", None
    except requests.exceptions.Timeout:
        return "Broken (Timeout)", None
    except requests.exceptions.ConnectionError:
        return "Broken (Connection Error)", None
    except Exception:
        return "Broken (Unknown Error)", None

def check_azure_blob(url):
    """Specific check for Azure Blob 'ContainerNotFound' vulnerability."""
    try:
        response = requests.get(url, timeout=5, headers=REQUEST_HEADERS)
        if response.status_code == 404 and "<Code>ContainerNotFound</Code>" in response.text:
            return "Broken", "CRITICAL: Azure Blob container does not exist and is available for registration ('ContainerNotFound')."
        if response.status_code == 200:
            return "OK", None
        return f"Info ({response.status_code})", None
    except requests.exceptions.Timeout:
        return "Broken (Timeout)", None
    except requests.exceptions.ConnectionError:
        return "Broken (Connection Error)", None
    except Exception:
        return "Broken (Unknown Error)", None

def check_dangling_dns(domain):
    """
    This checks for expired domains or CNAMEs pointing to non-existent resources.
    """
    
    # 1. Check for Expired/Available Domain
    try:
        w = whois.query(domain)
        if w is None or "No match for domain" in str(w) or "available for registration" in str(w):
            return "CRITICAL: Domain is available for registration."
    except Exception:
        pass 

    # 2. Check for Dangling DNS (CNAME pointing to nothing)
    try:
        cname_records = dns.resolver.resolve(domain, 'CNAME')
        if not cname_records:
            return "Warning: Link is broken, but hijack vector not automatically confirmed (No CNAME)."
        
        cname_target = cname_records[0].target.to_text(omit_final_dot=True)
        
        try:
            dns.resolver.resolve(cname_target)
        except dns.resolver.NXDOMAIN:
            return f"CRITICAL: Dangling DNS. CNAME points to non-existent resource: {cname_target}"
        except dns.resolver.NoAnswer:
            pass

    except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer, dns.resolver.NoNameservers, dns.resolver.NoMetaqueries):
        return "Warning: Domain does not resolve (NXDOMAIN)."
    except dns.resolver.NoRootSOA:
        return "Warning: Domain does not resolve (NoRootSOA)."
    except Exception:
        pass 
        
    return "Warning: Link is broken, but hijack vector not automatically confirmed."

def main():
    parser = argparse.ArgumentParser(description="MISS Framework BLH Scanner")
    parser.add_argument("--directory", default=".", help="Directory to scan")
    parser.add_argument("--output", default="blh_report.json", help="Output JSON report file")
    
    # --- NEW ---
    parser.add_argument(
        "--level", 
        default="critical", 
        choices=['warning', 'critical'],
        help="Minimum vulnerability level to report (default: critical)"
    )
    # --- END NEW ---
    
    args = parser.parse_args()
    report_level = args.level.upper() # 'CRITICAL' or 'WARNING'

    print(f"Starting BLH Scan in: {args.directory}")
    print(f"Reporting level set to: {report_level}")
    print("Scanning ALL file types...")
    
    all_links = set()
    file_map = {}

    for root, dirs, files in os.walk(args.directory):
        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
        
        for file in files:
            filepath = os.path.join(root, file)
            links_in_file = find_links_in_file(filepath)
            for link in links_in_file:
                all_links.add(link)
                if link not in file_map:
                    file_map[link] = []
                file_map[link].append(filepath)

    print(f"Found {len(all_links)} unique links. Analyzing...")
    
    results = []
    
    for i, link in enumerate(all_links):
        print(f"Checking [{i+1}/{len(all_links)}] {link}...")
        
        domain = urlparse(link).hostname
        
        # --- NEW: Validation and Filtering ---
        if not is_valid_domain(domain):
            print(f"  -> INFO: Skipping invalid or garbage domain: {domain}")
            continue
            
        # Check if the domain *ends with* any of the ignored domains
        if any(domain.endswith(ignored) for ignored in IGNORE_DOMAINS):
            print(f"  -> INFO: Skipping ignored domain: {domain}")
            continue
        # --- END NEW ---
        
        status = "OK"
        vulnerability = None

        if 's3.amazonaws.com' in domain:
            status, vulnerability = check_s3_bucket(link)
        elif 'blob.core.windows.net' in domain:
            status, vulnerability = check_azure_blob(link)
        else:
            status = check_http_status(link)
            if status != "OK":
                vulnerability = check_dangling_dns(domain)
        
        time.sleep(0.1) 

        if status != "OK":
            # --- NEW: Level-based reporting ---
            is_critical = vulnerability and "CRITICAL" in vulnerability
            
            # Add to report if...
            # 1. The report level is 'warning' (we report everything)
            # OR
            # 2. The report level is 'critical' AND this finding is critical
            if report_level == 'WARNING' or (report_level == 'CRITICAL' and is_critical):
                result = {
                    "link": link,
                    "status": status,
                    "domain": domain,
                    "vulnerability_type": vulnerability,
                    "found_in": file_map[link]
                }
                print(f"  -> VULNERABLE: {status} - {vulnerability}")
                results.append(result)
            else:
                # We found a 'warning' but the user only wants 'critical'
                print(f"  -> INFO: Skipping 'Warning' level finding (not critical).")
            # --- END NEW ---

    report_data = {
        "summary": {
            "total_links_scanned": len(all_links),
            "vulnerabilities_found": len(results),
            "report_level": report_level
        },
        "vulnerabilities": results
    }
    
    with open(args.output, 'w', encoding='utf-8') as f:
        json.dump(report_data, f, indent=2)

    print(f"\nScan complete. Report saved to {args.output}")

if __name__ == "__main__":
    main()
```eof

### 3. The Demo Workflow (To use the new feature)

You don't *need* to change your `scan-demo.yml` file since the default in `action.yml` is now `critical`. But if you wanted to explicitly set it (or change it to `warning`), here is how:

```yaml:Demo Workflow:scan-demo.yml
name: 'BLH Scan Demo'

on:
  workflow_dispatch: # Allows manual triggering

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4

      - name: 'Run BLH Scanner (MISS Framework)'
        id: blh_scan
        uses: ./.github/actions/blh-scanner # Assumes your action is here
        with:
          # --- NEW ---
          # This will now only report 'CRITICAL' findings
          level: 'critical' 
          # Change to 'warning' to see all 300+ broken links
          
          # --- END NEW ---
          report-name: 'blh_report.json'

      - name: 'Upload Scan Report'
        if: always() # Always upload, even if the scan step fails
        uses: actions/upload-artifact@v4
        with:
          name: blh-report
          path: ${{ steps.blh_scan.outputs.report_path }}
```eof
